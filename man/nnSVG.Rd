% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nnSVG.R
\name{nnSVG}
\alias{nnSVG}
\title{nnSVG}
\usage{
nnSVG(
  spe,
  x = NULL,
  filter_genes = 20,
  filter_mito = TRUE,
  n_threads = 1,
  verbose = FALSE
)
}
\arguments{
\item{spe}{\code{SpatialExperiment} Input data, assumed to be a 
\code{\link{SpatialExperiment}} object containing an assay named 
\code{logcounts} containing log-transformed normalized counts, and 
spatial coordinates stored in the \code{spatialCoords} slot.}

\item{x}{\code{numeric matrix} Optional matrix of covariates (e.g. known 
cell types) per spatial coordinate. Number of rows must match the number 
of spatial coordinates (columns) in the input object \code{spe}. Default = 
NULL, which fits an intercept-only model.}

\item{filter_genes}{\code{integer} Whether to filter low-expressed genes 
according to total unique molecular identifier (UMI) counts per gene 
across spatial coordinates. If an integer value is provided, genes with 
less than or equal to this number of total UMI counts across spatial 
coordinates will be removed. Assumes \code{spe} contains an assay named 
\code{counts} containing raw UMI counts. Default = 20. Set to NULL to 
disable.}

\item{filter_mito}{\code{logical} Whether to filter mitochondrial genes. 
Assumes the \code{rowData} slot of \code{spe} contains a column named 
\code{gene_name}, which can be used to identify mitochondrial genes. 
Default = TRUE. Set to FALSE to disable.}

\item{n_threads}{\code{integer} Number of threads for parallelization. 
Default = 1.}

\item{verbose}{\code{logical} Whether to display verbose output from 
\code{BRISC}. Default = FALSE.}
}
\value{
Returns output values (including parameter estimates, likelihood 
  ratios, and adjusted p-values) in the \code{rowData} slot in the 
  \code{spe} \code{SpatialExperiment} object.
}
\description{
Run 'nnSVG' to identify spatially variable genes
}
\details{
Run 'nnSVG' method to identify spatially variable genes (SVGs) in spatially 
resolved transcriptomics data.

The method is based on nearest neighbor Gaussian processes (Datta et al. 
2016) and uses the BRISC algorithm (Saha and Datta 2018). The method scales 
linearly in the number of spatial coordinates, and can be applied to 
datasets containing thousands of spatial coordinates.

This function runs BRISC once per gene for model fitting and parameter 
estimation, using parallelization for faster runtime with one core per BRISC 
run. The spatial covariance parameter estimates (sigma.sq, tau.sq, phi) from 
BRISC are stored in 'Theta' in the BRISC output.

nnSVG performs inference on the 'sigma.sq' estimates using an approximate 
likelihood ratio test against a model without spatial terms, and uses these 
likelihood ratios to rank SVGs. We also calculate an effect size, defined as 
the proportion of spatial variance out of total variance, i.e. 'prop_sv = 
sigma.sq / (sigma.sq + tau.sq)'.

Likelihood ratio tests are calculated using the asymptotic chi-squared 
distribution with 2 degrees of freedom, and adjusted p-values using the 
Benjamini-Hochberg method.

Assumes the input is provided as a \code{\link{SpatialExperiment}} object 
containing an assay named \code{logcounts}, which contains log-transformed 
normalized counts (e.g. using methods from the \code{scater} package; 
McCarthy et al. 2017), and which has been filtered to remove low-quality 
spatial coordinates.

Low-expressed genes can be filtered before providing the input to `nnSVG()`, 
or using the default filtering arguments in `nnSVG()`.
}
\examples{
library(SpatialExperiment)
library(STexampleData)
library(nnSVG)

spe <- Visium_humanDLPFC()

spe <- preprocessSVG(spe)

# subset 1 gene
spe_1 <- spe[1, ]
spe_1 <- nnSVG(spe_1, verbose = TRUE)

# subset 100 genes and use parallelization
# spe_100 <- spe[1:100, ]
# spe_100 <- nnSVG(spe_100, n_threads = 4)

}
